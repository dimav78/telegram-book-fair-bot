import logging
import os
import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from dotenv import load_dotenv

# --- Load environment variables ---
load_dotenv()

# --- Import your sheets functions ---
import sheets_handler

# --- Get configuration from environment ---
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')

# --- Basic Logging Setup ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)


# --- Command Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message when the /start command is issued."""
    keyboard = [
        [InlineKeyboardButton("–í—ã–±–æ—Ä –ø–æ –∞–≤—Ç–æ—Ä—É", callback_data='select_author')],
        [InlineKeyboardButton("–ö–æ—Ä–∑–∏–Ω–∞", callback_data='view_cart')],
        [InlineKeyboardButton("–ò—Ç–æ–≥–∏", callback_data='view_totals')],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–∞—Å—Å—É –∫–Ω–∏–∂–Ω–æ–π —è—Ä–º–∞—Ä–∫–∏! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:',
        reply_markup=reply_markup
    )


# --- Callback Query Handler ---
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles callback queries from inline keyboards."""
    query = update.callback_query
    await query.answer()
    
    if query.data == 'select_author':
        await show_authors(query, context)
    elif query.data.startswith('author_'):
        author_id = int(query.data.split('_')[1])
        await show_products_by_author(query, context, author_id)
    elif query.data.startswith('product_'):
        product_id = int(query.data.split('_')[1])
        await show_product_details(query, context, product_id)
    elif query.data.startswith('add_to_cart_'):
        product_id = int(query.data.split('_')[3])
        await add_to_cart(query, context, product_id)
    elif query.data == 'view_cart':
        await show_cart(query, context)
    elif query.data == 'view_totals':
        await show_totals(query, context)
    elif query.data == 'payment_cashless':
        await handle_cashless_payment(query, context)
    elif query.data == 'payment_cash':
        await handle_cash_payment(query, context)
    elif query.data == 'clear_cart':
        await clear_cart(query, context)
    elif query.data == 'confirm_cashless':
        await confirm_payment(query, context, 'cashless')
    elif query.data == 'confirm_cash':
        await confirm_payment(query, context, 'cash')
    elif query.data == 'back_to_main':
        await handle_back_to_main(query, context)


async def show_authors(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows a list of authors as inline keyboard buttons."""
    authors = sheets_handler.get_authors()
    
    if not authors:
        await query.edit_message_text("–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞–≤—Ç–æ—Ä–æ–≤.")
        return
    
    keyboard = []
    for author in authors:
        author_name = author.get('Name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä')
        author_id = author.get('AuthorID')
        keyboard.append([InlineKeyboardButton(author_name, callback_data=f'author_{author_id}')])
    
    # Add back button
    keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data='back_to_main')])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text('–í—ã–±–µ—Ä–∏—Ç–µ –∞–≤—Ç–æ—Ä–∞:', reply_markup=reply_markup)


async def show_products_by_author(query, context: ContextTypes.DEFAULT_TYPE, author_id: int) -> None:
    """Shows products by selected author."""
    products = sheets_handler.get_products_by_author(author_id)
    
    if not products:
        keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è –ö –∞–≤—Ç–æ—Ä–∞–º", callback_data='select_author')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("–£ —ç—Ç–æ–≥–æ –∞–≤—Ç–æ—Ä–∞ –ø–æ–∫–∞ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–Ω–∏–≥.", reply_markup=reply_markup)
        return
    
    keyboard = []
    for product in products:
        product_title = product.get('Title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        product_id = product.get('ProductID')
        keyboard.append([InlineKeyboardButton(product_title, callback_data=f'product_{product_id}')])
    
    # Add back button
    keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ö –∞–≤—Ç–æ—Ä–∞–º", callback_data='select_author')])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text('–í—ã–±–µ—Ä–∏—Ç–µ –∫–Ω–∏–≥—É:', reply_markup=reply_markup)


async def show_product_details(query, context: ContextTypes.DEFAULT_TYPE, product_id: int) -> None:
    """Shows product details with photo and add to cart button."""
    # Get all products to find the specific one
    authors = sheets_handler.get_authors()
    all_products = []
    
    for author in authors:
        author_id = author.get('AuthorID')
        products = sheets_handler.get_products_by_author(author_id)
        all_products.extend(products)
    
    product = None
    for p in all_products:
        if p.get('ProductID') == product_id:
            product = p
            break
    
    if not product:
        await query.edit_message_text("–ö–Ω–∏–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return
    
    title = product.get('Title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
    description = product.get('Description', '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')
    price = product.get('Price', 0)
    photo_url = product.get('Photo_URL', '')
    author_id = product.get('AuthorID')
    
    # Find author name
    author_name = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä'
    for author in authors:
        if author.get('AuthorID') == author_id:
            author_name = author.get('Name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä')
            break
    
    message_text = f"üìö *{title}*\n\nüë§ –ê–≤—Ç–æ—Ä: {author_name}\nüí∞ –¶–µ–Ω–∞: {price} —Ä—É–±.\n\nüìù {description}"
    
    keyboard = [
        [InlineKeyboardButton("üõí –î–æ–±–∞–≤–∏—Ç—å –≤ –∫–æ—Ä–∑–∏–Ω—É", callback_data=f'add_to_cart_{product_id}')],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ö –∫–Ω–∏–≥–∞–º –∞–≤—Ç–æ—Ä–∞", callback_data=f'author_{author_id}')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    try:
        if photo_url:
            await query.edit_message_media(
                media=telegram.InputMediaPhoto(media=photo_url, caption=message_text, parse_mode='Markdown'),
                reply_markup=reply_markup
            )
        else:
            await query.edit_message_text(text=message_text, parse_mode='Markdown', reply_markup=reply_markup)
    except Exception as e:
        logger.error(f"Error sending product details: {e}")
        await query.edit_message_text(text=message_text, parse_mode='Markdown', reply_markup=reply_markup)


async def add_to_cart(query, context: ContextTypes.DEFAULT_TYPE, product_id: int) -> None:
    """Adds a product to the user's cart."""
    if 'cart' not in context.user_data:
        context.user_data['cart'] = []
    
    # Find the product details
    authors = sheets_handler.get_authors()
    all_products = []
    
    for author in authors:
        author_id = author.get('AuthorID')
        products = sheets_handler.get_products_by_author(author_id)
        all_products.extend(products)
    
    product = None
    for p in all_products:
        if p.get('ProductID') == product_id:
            product = p
            break
    
    if product:
        context.user_data['cart'].append(product)
        title = product.get('Title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        await query.answer(f"‚úÖ '{title}' –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É!")
        
        # Show updated options
        keyboard = [
            [InlineKeyboardButton("üõí –ö–æ—Ä–∑–∏–Ω–∞", callback_data='view_cart')],
            [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data='select_author')],
            [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data='back_to_main')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Try to edit message text, if it fails (media message), send new message
        try:
            await query.edit_message_text(
                f"‚úÖ '{title}' –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É!\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º –¥–∞–ª—å—à–µ?",
                reply_markup=reply_markup
            )
        except telegram.error.BadRequest as e:
            if "no text in the message to edit" in str(e).lower():
                # Previous message was media, delete and send new text message
                await query.message.delete()
                await query.message.reply_text(
                    f"‚úÖ '{title}' –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É!\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º –¥–∞–ª—å—à–µ?",
                    reply_markup=reply_markup
                )
            else:
                raise e
    else:
        await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –∫–æ—Ä–∑–∏–Ω—É")


async def show_cart(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the contents of the user's cart."""
    cart = context.user_data.get('cart', [])
    
    if not cart:
        keyboard = [[InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–∏–≥–∏", callback_data='select_author')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("üõí –í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞", reply_markup=reply_markup)
        return
    
    message_lines = ["üõí *–í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞:*\n"]
    total = 0
    
    for i, product in enumerate(cart, 1):
        title = product.get('Title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        price = product.get('Price', 0)
        total += price
        message_lines.append(f"{i}. {title} - {price} —Ä—É–±.")
    
    message_lines.append(f"\nüí∞ *–û–±—â–∞—è —Å—É–º–º–∞: {total} —Ä—É–±.*")
    
    keyboard = [
        [InlineKeyboardButton("üí≥ –ë–µ–∑–Ω–∞–ª", callback_data='payment_cashless'),
         InlineKeyboardButton("üíµ –ù–∞–ª–∏—á–Ω—ã–µ", callback_data='payment_cash')],
        [InlineKeyboardButton("üóë –û—á–∏—Å—Ç–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É", callback_data='clear_cart')],
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data='select_author')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text('\n'.join(message_lines), parse_mode='Markdown', reply_markup=reply_markup)


async def handle_cashless_payment(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles cashless payment with QR code or contact display."""
    cart = context.user_data.get('cart', [])
    
    if not cart:
        await query.answer("‚ùå –ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞")
        return
    
    # Calculate total and get author info
    total = sum(product.get('Price', 0) for product in cart)
    
    # Get author info from first product (assuming single author per transaction)
    first_product = cart[0]
    author_id = first_product.get('AuthorID')
    
    # Find author details
    authors = sheets_handler.get_authors()
    author = None
    for a in authors:
        if a.get('AuthorID') == author_id:
            author = a
            break
    
    if not author:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –∞–≤—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    qr_code_url = author.get('QR_Code_URL', '').strip()
    contact = author.get('Contact', '').strip()
    author_name = author.get('Name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä')
    
    # Create cart summary
    cart_lines = [f"üí≥ *–ë–µ–∑–Ω–∞–ª–∏—á–Ω–∞—è –æ–ø–ª–∞—Ç–∞*\n"]
    cart_lines.append(f"üë§ –ê–≤—Ç–æ—Ä: {author_name}")
    cart_lines.append(f"üí∞ –°—É–º–º–∞: {total} —Ä—É–±.\n")
    
    for i, product in enumerate(cart, 1):
        title = product.get('Title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        price = product.get('Price', 0)
        cart_lines.append(f"{i}. {title} - {price} —Ä—É–±.")
    
    message_text = '\n'.join(cart_lines)
    
    keyboard = [
        [InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É", callback_data='confirm_cashless')],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∫–æ—Ä–∑–∏–Ω–µ", callback_data='view_cart')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    try:
        if qr_code_url:
            # Display QR code image
            await query.edit_message_media(
                media=telegram.InputMediaPhoto(
                    media=qr_code_url, 
                    caption=message_text + f"\n\nüì± –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –¥–ª—è –æ–ø–ª–∞—Ç—ã",
                    parse_mode='Markdown'
                ),
                reply_markup=reply_markup
            )
        elif contact:
            # Display contact info only
            await query.edit_message_text(
                text=message_text + f"\n\nüìû –ö–æ–Ω—Ç–∞–∫—Ç –¥–ª—è –æ–ø–ª–∞—Ç—ã: {contact}",
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
        else:
            # No payment info available
            await query.edit_message_text(
                text=message_text + "\n\n‚ùå –ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –æ–ø–ª–∞—Ç—ã",
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
    except Exception as e:
        logger.error(f"Error displaying cashless payment: {e}")
        # Fallback to text only
        fallback_text = message_text
        if contact:
            fallback_text += f"\n\nüìû –ö–æ–Ω—Ç–∞–∫—Ç –¥–ª—è –æ–ø–ª–∞—Ç—ã: {contact}"
        else:
            fallback_text += "\n\n‚ùå –ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –æ–ø–ª–∞—Ç—ã"
        
        await query.edit_message_text(
            text=fallback_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )


async def handle_cash_payment(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles cash payment."""
    cart = context.user_data.get('cart', [])
    
    if not cart:
        await query.answer("‚ùå –ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞")
        return
    
    total = sum(product.get('Price', 0) for product in cart)
    
    # Create cart summary
    cart_lines = [f"üíµ *–û–ø–ª–∞—Ç–∞ –Ω–∞–ª–∏—á–Ω—ã–º–∏*\n"]
    cart_lines.append(f"üí∞ –°—É–º–º–∞: {total} —Ä—É–±.\n")
    
    for i, product in enumerate(cart, 1):
        title = product.get('Title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        price = product.get('Price', 0)
        cart_lines.append(f"{i}. {title} - {price} —Ä—É–±.")
    
    message_text = '\n'.join(cart_lines)
    
    keyboard = [
        [InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É", callback_data='confirm_cash')],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∫–æ—Ä–∑–∏–Ω–µ", callback_data='view_cart')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        text=message_text + "\n\nüíµ –ü—Ä–∏–º–∏—Ç–µ –æ–ø–ª–∞—Ç—É –Ω–∞–ª–∏—á–Ω—ã–º–∏",
        parse_mode='Markdown',
        reply_markup=reply_markup
    )


async def clear_cart(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Clears the user's cart."""
    context.user_data['cart'] = []
    
    keyboard = [
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–∏–≥–∏", callback_data='select_author')],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        "üóë –ö–æ—Ä–∑–∏–Ω–∞ –æ—á–∏—â–µ–Ω–∞",
        reply_markup=reply_markup
    )


async def confirm_payment(query, context: ContextTypes.DEFAULT_TYPE, payment_method: str) -> None:
    """Confirms payment and records transactions."""
    cart = context.user_data.get('cart', [])
    
    if not cart:
        await query.answer("‚ùå –ö–æ—Ä–∑–∏–Ω–∞ –ø—É—Å—Ç–∞")
        return
    
    # Record each product as a separate transaction
    successful_transactions = 0
    failed_transactions = 0
    
    for product in cart:
        product_id = product.get('ProductID')
        author_id = product.get('AuthorID')
        price = product.get('Price', 0)
        
        success = sheets_handler.record_transaction(product_id, author_id, payment_method, price)
        if success:
            successful_transactions += 1
        else:
            failed_transactions += 1
    
    # Clear cart after recording transactions
    context.user_data['cart'] = []
    
    # Prepare result message
    total_amount = sum(product.get('Price', 0) for product in cart)
    payment_emoji = "üí≥" if payment_method == "cashless" else "üíµ"
    payment_text = "–±–µ–∑–Ω–∞–ª–∏—á–Ω–∞—è" if payment_method == "cashless" else "–Ω–∞–ª–∏—á–Ω—ã–º–∏"
    
    if failed_transactions == 0:
        result_message = f"‚úÖ –û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n{payment_emoji} {payment_text.capitalize()}: {total_amount} —Ä—É–±.\nüìù –ó–∞–ø–∏—Å–∞–Ω–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: {successful_transactions}"
    else:
        result_message = f"‚ö†Ô∏è –û–ø–ª–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–∞–º–∏!\n\n{payment_emoji} {payment_text.capitalize()}: {total_amount} —Ä—É–±.\n‚úÖ –£—Å–ø–µ—à–Ω–æ: {successful_transactions}\n‚ùå –û—à–∏–±–æ–∫: {failed_transactions}"
    
    keyboard = [
        [InlineKeyboardButton("‚ûï –ù–æ–≤–∞—è –ø—Ä–æ–¥–∞–∂–∞", callback_data='select_author')],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        result_message,
        reply_markup=reply_markup
    )


async def show_totals(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows daily totals (placeholder implementation)."""
    await query.edit_message_text("üìä –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏—Ç–æ–≥–æ–≤ –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –ø–æ–∑–¥–Ω–µ–µ.")


async def handle_back_to_main(query, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Returns to main menu."""
    keyboard = [
        [InlineKeyboardButton("–í—ã–±–æ—Ä –ø–æ –∞–≤—Ç–æ—Ä—É", callback_data='select_author')],
        [InlineKeyboardButton("–ö–æ—Ä–∑–∏–Ω–∞", callback_data='view_cart')],
        [InlineKeyboardButton("–ò—Ç–æ–≥–∏", callback_data='view_totals')],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–∞—Å—Å—É –∫–Ω–∏–∂–Ω–æ–π —è—Ä–º–∞—Ä–∫–∏! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:',
        reply_markup=reply_markup
    )


# --- Main Bot Logic ---
def main() -> None:
    """Start the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(TELEGRAM_TOKEN).build()

    # --- Register Handlers ---
    # Register the /start command
    application.add_handler(CommandHandler("start", start))
    
    # Register the callback query handler for button presses
    application.add_handler(CallbackQueryHandler(button_handler))

    # Start the Bot
    print("Bot is running...")
    application.run_polling()


if __name__ == '__main__':
    main()